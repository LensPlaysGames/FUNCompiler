/// This file should NOT have a header guard.
#include <stdio.h>

/// Variadic macro black magic.
#ifndef FOR_EACH
/// Macro that takes a macro and arguments and applies the macro to each argument.
/// For example `FOR_EACH(FOO, a, b, c)` expands to `FOO(a) FOO(b) FOO(c)`.
# define FOR_EACH(macro, ...) FOR_EACH_NTH(__VA_ARGS__, _9, _8, _7, _6, _5, _4, _3, _2, _1, _0)(macro, __VA_ARGS__)
# define FOR_EACH_NTH(_9, _8, _7, _6, _5, _4, _3, _2, _1, N, ...) FOR_EACH##N

# define FOR_EACH_0(macro, x, ...)
# define FOR_EACH_1(macro, x, ...) macro(x)
# define FOR_EACH_2(macro, x, ...) macro(x) FOR_EACH_1(macro, __VA_ARGS__)
# define FOR_EACH_3(macro, x, ...) macro(x) FOR_EACH_2(macro, __VA_ARGS__)
# define FOR_EACH_4(macro, x, ...) macro(x) FOR_EACH_3(macro, __VA_ARGS__)
# define FOR_EACH_5(macro, x, ...) macro(x) FOR_EACH_4(macro, __VA_ARGS__)
# define FOR_EACH_6(macro, x, ...) macro(x) FOR_EACH_5(macro, __VA_ARGS__)
# define FOR_EACH_7(macro, x, ...) macro(x) FOR_EACH_6(macro, __VA_ARGS__)
# define FOR_EACH_8(macro, x, ...) macro(x) FOR_EACH_7(macro, __VA_ARGS__)
# define FOR_EACH_9(macro, x, ...) macro(x) FOR_EACH_8(macro, __VA_ARGS__)

/// Macro that takes a macro and arguments and applies the macro the arguments, two at a time.
/// For example `FOR_EACH_PAIR(FOO, a, b, c, d)` expands to `FOO(a, b) FOO(c, d)`.
# define FOR_EACH_PAIR(macro, ...) FOR_EACH_PAIR_NTH(__VA_ARGS__, _4, _4, _3, _3, _2, _2, _1, _1, _0, _0)(macro, __VA_ARGS__)
# define FOR_EACH_PAIR_NTH(_9, _8, _7, _6, _5, _4, _3, _2, _1, N, ...) FOR_EACH_PAIR##N

# define FOR_EACH_PAIR_0(...)
# define FOR_EACH_PAIR_1(macro, x, y, ...) macro(x, y)
# define FOR_EACH_PAIR_2(macro, x, y, ...) macro(x, y) FOR_EACH_PAIR_1(macro, __VA_ARGS__)
# define FOR_EACH_PAIR_3(macro, x, y, ...) macro(x, y) FOR_EACH_PAIR_2(macro, __VA_ARGS__)
# define FOR_EACH_PAIR_4(macro, x, y, ...) macro(x, y) FOR_EACH_PAIR_3(macro, __VA_ARGS__)

/// Macro that takes a macro, a separator, and arguments and applies the macro the
/// arguments, two at a time, and inserts the separator between each application.
/// The separator must be a function-like macro that takes no arguments.
///
/// For example `FOR_EACH_PAIR_JOIN(FOO, SEP, a, b, c, d, e, f)` expands to `FOO(a, b) SEP() FOO(c, d) SEP() FOO(e, f)`.
# define FOR_EACH_PAIR_JOIN(macro, separator, ...) FOR_EACH_PAIR_JOIN_NTH(__VA_ARGS__, _4, _4, _3, _3, _2, _2, _1, _1, _0, _0)(macro, separator, __VA_ARGS__)
# define FOR_EACH_PAIR_JOIN_NTH(_9, _8, _7, _6, _5, _4, _3, _2, _1, N, ...) FOR_EACH_PAIR_JOIN##N

# define FOR_EACH_PAIR_JOIN_0(...)
# define FOR_EACH_PAIR_JOIN_1(macro, separator, x, y, ...) macro(x, y)
# define FOR_EACH_PAIR_JOIN_2(macro, separator, x, y, ...) macro(x, y) separator() FOR_EACH_PAIR_JOIN_1(macro, separator, __VA_ARGS__)
# define FOR_EACH_PAIR_JOIN_3(macro, separator, x, y, ...) macro(x, y) separator() FOR_EACH_PAIR_JOIN_2(macro, separator, __VA_ARGS__)
# define FOR_EACH_PAIR_JOIN_4(macro, separator, x, y, ...) macro(x, y) separator() FOR_EACH_PAIR_JOIN_3(macro, separator, __VA_ARGS__)

# define CONCATENATE_(a, b) a##b
# define CONCATENATE(a, b) CONCATENATE_(a, b)

# define VA_SEPARATOR_COMMA() ,
#endif

/// This is so we don't depend on error.h.
#ifndef FORMAT
# ifndef _MSC_VER
#   define FORMAT(...) __attribute__((format(__VA_ARGS__)))
# else
#   define FORMAT(...)
# endif
#endif

#ifndef CODEGEN_API_PARAMS_DECLARE
# define CODEGEN_API_PARAMS_DECLARE(type, name) type name
#endif

#ifndef CODEGEN_API_FUNCTION_NAME
#define CODEGEN_API_FUNCTION_NAME(name) name
#endif

#ifndef CODEGEN_API_FUNCTION
# define CODEGEN_API_FUNCTION(ret, name, ...) ret CODEGEN_API_FUNCTION_NAME(name) (FOR_EACH_PAIR_JOIN(CODEGEN_API_PARAMS_DECLARE, VA_SEPARATOR_COMMA, CodegenContext*, ctx, __VA_ARGS__))
#endif

///  Create a top-level codegen context.
CodegenContext * CODEGEN_API_FUNCTION_NAME(codegen_context_create_top_level)
(enum CodegenOutputFormat format,
 enum CodegenCallingConvention call_convention,
 enum CodegenAssemblyDialect dialect,
 FILE* code);

///  Create a codegen context from a parent context.
CodegenContext * CODEGEN_API_FUNCTION_NAME(codegen_context_create)(CodegenContext *parent);

///  Free a codegen context.
void CODEGEN_API_FUNCTION_NAME(codegen_context_free)(CodegenContext *parent);

///  Save state before a function call.
CODEGEN_API_FUNCTION(void, codegen_prepare_call);

///  Add an argument to the current external function call.
CODEGEN_API_FUNCTION(void, codegen_add_external_function_arg,
  RegisterDescriptor, arg);

///  Add an argument to the current function call.
CODEGEN_API_FUNCTION(void, codegen_add_internal_function_arg,
  RegisterDescriptor, arg);

///  Call an external function. Return the register containing the return value.
CODEGEN_API_FUNCTION(RegisterDescriptor, codegen_perform_external_call,
  const char*, function_name);

///  Call an internal function. Return the register containing the return value.
CODEGEN_API_FUNCTION(RegisterDescriptor, codegen_perform_internal_call,
  RegisterDescriptor, function);

///  Clean up after a function call.
CODEGEN_API_FUNCTION(void, codegen_cleanup_call);

///  Load the address of global variable into a newly allocated register and return it.
CODEGEN_API_FUNCTION(RegisterDescriptor, codegen_load_global_address,
  const char*, name);

///  Load the address of local variable into a newly allocated register and return it.
CODEGEN_API_FUNCTION(RegisterDescriptor, codegen_load_local_address,
  long long int, offset);

///  Load the value of global variable into a newly allocated register and return it.
CODEGEN_API_FUNCTION(RegisterDescriptor, codegen_load_global,
  const char *, name);

///  Load the value of local variable into a newly allocated register and return it.
CODEGEN_API_FUNCTION(RegisterDescriptor, codegen_load_local,
  long long int, offset);

///  Store a global variable.
CODEGEN_API_FUNCTION(void, codegen_store_global,
  RegisterDescriptor, source, const char *, name);

///  Store a local variable.
CODEGEN_API_FUNCTION(void, codegen_store_local,
  RegisterDescriptor, source, long long int , offset);

///  Store data in the memory pointed to by the given address.
CODEGEN_API_FUNCTION(void, codegen_store,
  RegisterDescriptor, data, RegisterDescriptor , address);

///  Add an immediate value to a register.
CODEGEN_API_FUNCTION(void, codegen_add_immediate,
  RegisterDescriptor, reg, long long int , immediate);

///  Branch to a label if a register is zero.
CODEGEN_API_FUNCTION(void, codegen_branch_if_zero,
  RegisterDescriptor, reg, const char *, label);

///  Branch to a label.
CODEGEN_API_FUNCTION(void, codegen_branch,
  const char *, label);

///  Load an immediate value into a new register.
CODEGEN_API_FUNCTION(RegisterDescriptor, codegen_load_immediate,
  long long int , immediate);

///  Zero out a register.
CODEGEN_API_FUNCTION(void, codegen_zero_register,
  RegisterDescriptor , reg);

///  Copy a register to another register.
CODEGEN_API_FUNCTION(void, codegen_copy_register,
  RegisterDescriptor, src, RegisterDescriptor, dest);

///  Generate a comparison between two registers.
CODEGEN_API_FUNCTION(RegisterDescriptor, codegen_comparison,

  enum ComparisonType, type,
    RegisterDescriptor, lhs,
    RegisterDescriptor, rhs);

///  Add two registers together.
CODEGEN_API_FUNCTION(RegisterDescriptor, codegen_add,
  RegisterDescriptor, lhs, RegisterDescriptor, rhs);

///  Subtract rhs from lhs.
CODEGEN_API_FUNCTION(RegisterDescriptor, codegen_subtract,
  RegisterDescriptor, lhs, RegisterDescriptor, rhs);

///  Multiply two registers together.
CODEGEN_API_FUNCTION(RegisterDescriptor, codegen_multiply,
  RegisterDescriptor, lhs, RegisterDescriptor, rhs);

///  Divide lhs by rhs.
CODEGEN_API_FUNCTION(RegisterDescriptor, codegen_divide,
  RegisterDescriptor, lhs, RegisterDescriptor, rhs);

///  Modulo lhs by rhs.
CODEGEN_API_FUNCTION(RegisterDescriptor, codegen_modulo,
  RegisterDescriptor, lhs, RegisterDescriptor, rhs);

///  Shift lhs to the left by rhs.
CODEGEN_API_FUNCTION(RegisterDescriptor, codegen_shift_left,
  RegisterDescriptor, lhs, RegisterDescriptor, rhs);

///  Shift lhs to the right by rhs (arithmetic).
CODEGEN_API_FUNCTION(RegisterDescriptor, codegen_shift_right_arithmetic,
  RegisterDescriptor, lhs, RegisterDescriptor, rhs);

///  Allocate space on the stack.
CODEGEN_API_FUNCTION(void, codegen_alloca, long long int, size);

///  Emit the function prologue.
CODEGEN_API_FUNCTION(void, codegen_function_prologue, );

///  Emit the function epilogue.
CODEGEN_API_FUNCTION(void, codegen_function_epilogue, );

///  Set the return value of a function.
CODEGEN_API_FUNCTION(void, codegen_set_return_value, RegisterDescriptor, value);

///  Emit the entry point of the program.
CODEGEN_API_FUNCTION(void, codegen_entry_point, );

///  Dispose of a value. This frees any resources associated with the value.
CODEGEN_API_FUNCTION(void, codegen_dispose, RegisterDescriptor, value);

///  Create an empty phi node. This is used to merge control flow
///
///  A phi node is used to merge values from different control flow paths
///  into a single value. This is a very common operation in an SSA IR
///  and is used here to abstract away operations such as allocating an
///  empty register or copying values from one register to another.
///
///  The reasons why this exists are
///    - to abstract away the details of how values are allocated and moved;
///    - because not all architectures have a notion of registers;
///    - because they're a generally useful and widely used concept.
///
///  This API is used as follows:
///  ```c
///  PHI *phi = codegen_phi_create(cg_context);
///  codegen_phi_add_value(cg_context, phi, value1);
///  codegen_phi_add_value(cg_context, phi, value2);
///  RegisterDescriptor result = codegen_phi_finalise(cg_context, phi);
///  ```
CODEGEN_API_FUNCTION(PHI, codegen_phi_create, );

///  Add a value to a phi node.
CODEGEN_API_FUNCTION(void, codegen_phi_add_value, PHI, phi, RegisterDescriptor, value);

///  Add an immediate to a phi node.
CODEGEN_API_FUNCTION(void, codegen_phi_add_immediate, PHI, phi, long long int, imm);

///  Finalise a phi node. This returns the final value of the phi node.
CODEGEN_API_FUNCTION(RegisterDescriptor, codegen_phi_finalise, PHI, phi);

/// Create a comment.
CODEGEN_API_FUNCTION(void, codegen_vcomment, const char *, fmt, va_list, ap);

/// Create a comment.
/// Backends should implement `codegen_vcomment_*()` instead.
FORMAT(printf, 2, 3)
void codegen_comment(CodegenContext *ctx, const char* fmt, ...);

/// Create a comment if verbose mode is enabled.
/// Backends should implement `codegen_vcomment_verbose_*()` instead.
FORMAT(printf, 2, 3)
void codegen_comment_verbose(CodegenContext *ctx, const char* fmt, ...);

#undef CODEGEN_API_FUNCTION
#undef CODEGEN_API_FUNCTION_VARIADIC
#undef CODEGEN_API_FUNCTION_NAME