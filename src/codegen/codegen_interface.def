/// This file should NOT have a header guard.
#include <stdio.h>
#include <codegen/ir.h>

/// Variadic macro black magic.
#ifndef FOR_EACH
/// Macro that takes a macro and arguments and applies the macro to each argument.
/// For example `FOR_EACH(FOO, a, b, c)` expands to `FOO(a) FOO(b) FOO(c)`.
# define FOR_EACH(macro, ...) FOR_EACH_NTH(__VA_ARGS__, _9, _8, _7, _6, _5, _4, _3, _2, _1, _0)(macro, __VA_ARGS__)
# define FOR_EACH_NTH(_9, _8, _7, _6, _5, _4, _3, _2, _1, N, ...) FOR_EACH##N

# define FOR_EACH_0(macro, x, ...)
# define FOR_EACH_1(macro, x, ...) macro(x)
# define FOR_EACH_2(macro, x, ...) macro(x) FOR_EACH_1(macro, __VA_ARGS__)
# define FOR_EACH_3(macro, x, ...) macro(x) FOR_EACH_2(macro, __VA_ARGS__)
# define FOR_EACH_4(macro, x, ...) macro(x) FOR_EACH_3(macro, __VA_ARGS__)
# define FOR_EACH_5(macro, x, ...) macro(x) FOR_EACH_4(macro, __VA_ARGS__)
# define FOR_EACH_6(macro, x, ...) macro(x) FOR_EACH_5(macro, __VA_ARGS__)
# define FOR_EACH_7(macro, x, ...) macro(x) FOR_EACH_6(macro, __VA_ARGS__)
# define FOR_EACH_8(macro, x, ...) macro(x) FOR_EACH_7(macro, __VA_ARGS__)
# define FOR_EACH_9(macro, x, ...) macro(x) FOR_EACH_8(macro, __VA_ARGS__)

/// Macro that takes a macro and arguments and applies the macro the arguments, two at a time.
/// For example `FOR_EACH_PAIR(FOO, a, b, c, d)` expands to `FOO(a, b) FOO(c, d)`.
# define FOR_EACH_PAIR(macro, ...) FOR_EACH_PAIR_NTH(__VA_ARGS__, _4, _4, _3, _3, _2, _2, _1, _1, _0, _0)(macro, __VA_ARGS__)
# define FOR_EACH_PAIR_NTH(_9, _8, _7, _6, _5, _4, _3, _2, _1, N, ...) FOR_EACH_PAIR##N

# define FOR_EACH_PAIR_0(...)
# define FOR_EACH_PAIR_1(macro, x, y, ...) macro(x, y)
# define FOR_EACH_PAIR_2(macro, x, y, ...) macro(x, y) FOR_EACH_PAIR_1(macro, __VA_ARGS__)
# define FOR_EACH_PAIR_3(macro, x, y, ...) macro(x, y) FOR_EACH_PAIR_2(macro, __VA_ARGS__)
# define FOR_EACH_PAIR_4(macro, x, y, ...) macro(x, y) FOR_EACH_PAIR_3(macro, __VA_ARGS__)

/// Macro that takes a macro, a separator, and arguments and applies the macro the
/// arguments, two at a time, and inserts the separator between each application.
/// The separator must be a function-like macro that takes no arguments.
///
/// For example `FOR_EACH_PAIR_JOIN(FOO, SEP, a, b, c, d, e, f)` expands to `FOO(a, b) SEP() FOO(c, d) SEP() FOO(e, f)`.
# define FOR_EACH_PAIR_JOIN(macro, separator, ...) FOR_EACH_PAIR_JOIN_NTH(__VA_ARGS__, _4, _4, _3, _3, _2, _2, _1, _1, _0, _0)(macro, separator, __VA_ARGS__)
# define FOR_EACH_PAIR_JOIN_NTH(_9, _8, _7, _6, _5, _4, _3, _2, _1, N, ...) FOR_EACH_PAIR_JOIN##N

# define FOR_EACH_PAIR_JOIN_0(...)
# define FOR_EACH_PAIR_JOIN_1(macro, separator, x, y, ...) macro(x, y)
# define FOR_EACH_PAIR_JOIN_2(macro, separator, x, y, ...) macro(x, y) separator() FOR_EACH_PAIR_JOIN_1(macro, separator, __VA_ARGS__)
# define FOR_EACH_PAIR_JOIN_3(macro, separator, x, y, ...) macro(x, y) separator() FOR_EACH_PAIR_JOIN_2(macro, separator, __VA_ARGS__)
# define FOR_EACH_PAIR_JOIN_4(macro, separator, x, y, ...) macro(x, y) separator() FOR_EACH_PAIR_JOIN_3(macro, separator, __VA_ARGS__)

# define CONCATENATE_(a, b) a##b
# define CONCATENATE(a, b) CONCATENATE_(a, b)

# define VA_SEPARATOR_COMMA() ,
#endif

/// This is so we don't depend on error.h.
#ifndef FORMAT
# ifndef _MSC_VER
#   define FORMAT(...) __attribute__((format(__VA_ARGS__)))
# else
#   define FORMAT(...)
# endif
#endif

#ifndef CODEGEN_API_PARAMS_DECLARE
# define CODEGEN_API_PARAMS_DECLARE(type, name) type name
#endif

#ifndef CODEGEN_API_FUNCTION_NAME
#define CODEGEN_API_FUNCTION_NAME(name) name
#endif

#ifndef CODEGEN_API_FUNCTION
# define CODEGEN_API_FUNCTION(ret, name, ...) ret CODEGEN_API_FUNCTION_NAME(name) (FOR_EACH_PAIR_JOIN(CODEGEN_API_PARAMS_DECLARE, VA_SEPARATOR_COMMA, CodegenContext*, ctx, __VA_ARGS__))
#endif

///  Create a top-level codegen context.
CodegenContext * CODEGEN_API_FUNCTION_NAME(codegen_context_create_top_level)
(enum CodegenOutputFormat format,
 enum CodegenCallingConvention call_convention,
 enum CodegenAssemblyDialect dialect,
 FILE* code);

/// Create a codegen context from a parent context.
CodegenContext * CODEGEN_API_FUNCTION_NAME(codegen_context_create)(CodegenContext *parent);

/// Free a codegen context.
void CODEGEN_API_FUNCTION_NAME(codegen_context_free)(CodegenContext *parent);

/// Add an argument to the current external function call.
CODEGEN_API_FUNCTION(Value *, codegen_create_call, char, external);

/// Add an argument to the current external function call.
CODEGEN_API_FUNCTION(void, codegen_add_function_arg,
  Value*, call, Value*, arg);

/// Create a new function
CODEGEN_API_FUNCTION(Function*, codegen_function_create, const char *, name);

/// Get a reference to a function
CODEGEN_API_FUNCTION(Value*, codegen_function_ref,
  Function *, function);

/// Create a basic block without attaching it.
CODEGEN_API_FUNCTION(BasicBlock *, codegen_basic_block_create_detached);

/// Create a basic block and attach it to the current function
CODEGEN_API_FUNCTION(BasicBlock *, codegen_basic_block_create);

/// Attach a block to the current function and set it as the insert point.
CODEGEN_API_FUNCTION(void, codegen_basic_block_attach, BasicBlock*, block);

/// Load the address of global variable into a newly allocated register and return it.
CODEGEN_API_FUNCTION(Value*, codegen_load_global_address,
  const char*, name);

/// Load the address of local variable into a newly allocated register and return it.
CODEGEN_API_FUNCTION(Value*, codegen_load_local_address,
  Value*, address);

/// Load the value of global variable into a newly allocated register and return it.
CODEGEN_API_FUNCTION(Value*, codegen_load_global,
  const char *, name);

///  Load the value of local variable into a newly allocated register and return it.
CODEGEN_API_FUNCTION(Value*, codegen_load_local,
  Value*, source);

///  Store a global variable.
CODEGEN_API_FUNCTION(void, codegen_store_global,
  Value*, source, const char *, name);

///  Store a local variable.
CODEGEN_API_FUNCTION(void, codegen_store_local,
  Value*, source, Value*, dest);

///  Store data in the memory pointed to by the given address.
CODEGEN_API_FUNCTION(void, codegen_store,
  Value*, data, Value*, address);

///  Branch to true_block if value is true, and to false_block otherwise.
CODEGEN_API_FUNCTION(void, codegen_branch_if,
  Value*, value, BasicBlock*, true_block, BasicBlock*, false_block);

///  Branch to a label.
CODEGEN_API_FUNCTION(void, codegen_branch,
  BasicBlock*, block);

///  Load an immediate value.
CODEGEN_API_FUNCTION(Value*, codegen_load_immediate,
  long long int , immediate);
/*
///  Zero out a register.
CODEGEN_API_FUNCTION(void, codegen_zero_register,
  Value* , reg);

///  Copy a register to another register.
CODEGEN_API_FUNCTION(void, codegen_copy_register,
  Value*, src, Value*, dest);*/

///  Generate a comparison between two registers.
CODEGEN_API_FUNCTION(Value*, codegen_comparison,
  enum ComparisonType, type,
  Value*, lhs,
  Value*, rhs);

///  Add two registers together.
CODEGEN_API_FUNCTION(Value*, codegen_add,
  Value*, lhs, Value*, rhs);

///  Subtract rhs from lhs.
CODEGEN_API_FUNCTION(Value*, codegen_subtract,
  Value*, lhs, Value*, rhs);

///  Multiply two registers together.
CODEGEN_API_FUNCTION(Value*, codegen_multiply,
  Value*, lhs, Value*, rhs);

///  Divide lhs by rhs.
CODEGEN_API_FUNCTION(Value*, codegen_divide,
  Value*, lhs, Value*, rhs);

///  Modulo lhs by rhs.
CODEGEN_API_FUNCTION(Value*, codegen_modulo,
  Value*, lhs, Value*, rhs);

///  Shift lhs to the left by rhs.
CODEGEN_API_FUNCTION(Value*, codegen_shift_left,
  Value*, lhs, Value*, rhs);

///  Shift lhs to the right by rhs (arithmetic).
CODEGEN_API_FUNCTION(Value*, codegen_shift_right_arithmetic,
  Value*, lhs, Value*, rhs);

///  Allocate space on the stack.
CODEGEN_API_FUNCTION(Value*, codegen_alloca, long long int, size);

///  Bind a function parameter.
CODEGEN_API_FUNCTION(Value*, codegen_bind_function_parameter,
  Function*, function, size_t, param_index);

///  Set the return value of a function.
CODEGEN_API_FUNCTION(void, codegen_set_return_value,
  Function*, function, Value*, value);

///  Set the entry point of the program.
CODEGEN_API_FUNCTION(void, codegen_entry_point,
  Function*, function);

///  Create an empty phi node. This is used to merge control flow
///
///  A phi node is used to merge values from different control flow paths
///  into a single value. This is a very common operation in an SSA IR
///  and is used here to abstract away operations such as allocating an
///  empty register or copying values from one register to another.
///
///  The reasons why this exists are
///    - to abstract away the details of how values are allocated and moved;
///    - because not all architectures have a notion of registers;
///    - because they're a generally useful and widely used concept.
///
///  This API is used as follows:
///  ```c
///  Value *phi = codegen_phi_create(cg_context);
///  codegen_phi_add(cg_context, phi, block1, value1);
///  codegen_phi_add(cg_context, phi, block2, value2);
///  ```
CODEGEN_API_FUNCTION(Value*, codegen_phi_create);

///  Add a value to a phi node.
CODEGEN_API_FUNCTION(void, codegen_phi_add,
  Value*, phi, BasicBlock*, block, Value*, value);

/// Create a comment.
CODEGEN_API_FUNCTION(void, codegen_vcomment, const char *, fmt, va_list, ap);

/// Create a comment.
/// Backends should implement `codegen_vcomment_*()` instead.
FORMAT(printf, 2, 3)
void codegen_comment(CodegenContext *ctx, const char* fmt, ...);

/// Create a comment if verbose mode is enabled.
/// Backends should implement `codegen_vcomment_verbose_*()` instead.
FORMAT(printf, 2, 3)
void codegen_comment_verbose(CodegenContext *ctx, const char* fmt, ...);

#undef CODEGEN_API_FUNCTION
#undef CODEGEN_API_FUNCTION_VARIADIC
#undef CODEGEN_API_FUNCTION_NAME